use super::word::{Word, WordError};

/// A parser for parsing bytes into sentences in the Mikrotik API sentence format.
///
/// The Mikrotik API uses a custom protocol to communicate. Each message is a sentence
/// composed of words. This structure represents a sentence and allows iterating over
/// its words.
///
/// Each word in a sentence is encoded with a length prefix, followed by the word's bytes.
/// The length is encoded in a variable number of bytes to save space for short words.
///
/// More details about the protocol can be found in the Mikrotik Wiki:
/// [Mikrotik API Protocol](https://wiki.mikrotik.com/wiki/Manual:API#Protocol)
///
/// returns SentenceError::Incomplete when the sentence is not completed with an empty word
pub fn next_sentence(data: &[u8]) -> Result<(Vec<Word>, usize), SentenceError> {
    let mut iterator = WordIterator { data, idx: 0 };
    let mut sentence = Vec::new();
    while let Some(item) = iterator.next() {
        match item {
            WordParserItem::Terminator => {
                return Ok((sentence, iterator.idx));
            }
            WordParserItem::Word(w) => {
                sentence.push(w);
            }
            WordParserItem::Error(e) => return Err(e),
        }
    }
    Err(SentenceError::Incomplete)
}

struct WordIterator<'a> {
    data: &'a [u8],
    idx: usize,
}
#[derive(Debug)]
enum WordParserItem<'a> {
    Terminator,
    Word(Word<'a>),
    Error(SentenceError),
}
impl<'a> Iterator for WordIterator<'a> {
    type Item = WordParserItem<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.idx >= self.data.len() {
            None
        } else {
            match read_length(&self.data[self.idx..]) {
                Ok((length, inc)) => {
                    if length as usize + inc + self.idx > self.data.len() {
                        None
                    } else {
                        self.idx += inc;
                        Some(if length == 0 {
                            WordParserItem::Terminator
                        } else {
                            let current_word_pos = self.idx;
                            self.idx += length as usize;
                            match Word::try_from(&self.data[current_word_pos..self.idx]) {
                                Ok(w) => WordParserItem::Word(w),
                                Err(e) => WordParserItem::Error(SentenceError::WordError(e)),
                            }
                        })
                    }
                }
                Err(e) => Some(WordParserItem::Error(e)),
            }
        }
    }
}

/// Specific errors that can occur while processing a byte sequence into a [`Sentence`].
///
/// Provides information about issues related to converting a sequence of bytes into a [`Sentence`].
#[derive(Debug, PartialEq)]
pub enum SentenceError {
    /// Error indicating that a sequence of bytes could not be parsed into a [`Word`].
    WordError(WordError),
    /// Error indicating that the prefix lenght of a [`Sentence`] is incorrect.
    /// This could happen if the length of the word is invalid or the data is corrupted.
    PrefixLength,
    // Error indicating that the category of the sentence is missing.
    // This could happen if the sentence does not start with a recognized category.
    // Valid categories are `!done`, `!re`, `!trap`, and `!fatal`.
    //Category,
    /// Error indicating the sentence is not complete (terminator is missing)
    Incomplete,
}

impl From<WordError> for SentenceError {
    fn from(e: WordError) -> Self {
        Self::WordError(e)
    }
}

/// Returns the length and the number of bytes read.
fn read_length(data: &[u8]) -> Result<(u32, usize), SentenceError> {
    let mut c: u32 = data[0] as u32;
    if c & 0x80 == 0x00 {
        Ok((c, 1))
    } else if c & 0xC0 == 0x80 {
        c &= !0xC0;
        c <<= 8;
        c += data[1] as u32;
        return Ok((c, 2));
    } else if c & 0xE0 == 0xC0 {
        c &= !0xE0;
        c <<= 8;
        c += data[1] as u32;
        c <<= 8;
        c += data[2] as u32;
        return Ok((c, 3));
    } else if c & 0xF0 == 0xE0 {
        c &= !0xF0;
        c <<= 8;
        c += data[1] as u32;
        c <<= 8;
        c += data[2] as u32;
        c <<= 8;
        c += data[3] as u32;
        return Ok((c, 4));
    } else if c & 0xF8 == 0xF0 {
        c = data[1] as u32;
        c <<= 8;
        c += data[2] as u32;
        c <<= 8;
        c += data[3] as u32;
        c <<= 8;
        c += data[4] as u32;
        return Ok((c, 5));
    } else {
        Err(SentenceError::PrefixLength)
    }
}

#[cfg(test)]
mod tests {
    use crate::protocol::word::{Word, WordAttribute, WordCategory};

    use super::*;

    #[test]
    fn test_sentence_iterator() {
        let data: &[u8] = &[
            0x05, b'!', b'd', b'o', b'n', b'e', // Word: !done
            0x08, b'.', b't', b'a', b'g', b'=', b'1', b'2', b'3', // Word: .tag=123
            0x0C, b'=', b'n', b'a', b'm', b'e', b'=', b'e', b't', b'h', b'e', b'r',
            b'1', // Word: =name=ether1
            0x00, // End of sentence
        ];

        let sentence = next_sentence(&data).unwrap().0;
        let mut sentence = sentence.into_iter();
        assert_eq!(sentence.next().unwrap(), Word::Category(WordCategory::Done));

        assert_eq!(sentence.next().unwrap(), Word::Tag(123));

        assert_eq!(
            sentence.next().unwrap(),
            Word::Attribute(("name", Some("ether1")).into())
        );

        assert_eq!(sentence.next(), None);
    }

    #[test]
    fn test_sentence_category_error() {
        // Test case where the first word is not a category
        let data: &[u8] = &[
            0x0A, b'.', b't', b'a', b'g', b'=', b'1', b'2', b'3', // Word: .tag=123
            0x0D, b'=', b'n', b'a', b'm', b'e', b'=', b'e', b't', b'h', b'e', b'r',
            b'1', // Word: =name=ether1
        ];
        let sentence = next_sentence(&data);

        assert!(sentence.is_err());
    }

    #[test]
    fn test_sentence_length_error() {
        // Test case where length is invalid
        let data: &[u8] = &[
            0xF8, b'.', b't', b'a', b'g', b'=', b'1', b'2', b'3', // Invalid length prefix
        ];

        let sentence = next_sentence(&data);

        assert!(sentence.is_err());
    }

    #[test]
    fn test_complete_sentence_parsing() {
        let data: &[u8] = &[
            0x05, b'!', b'd', b'o', b'n', b'e', // Word: !done
            0x08, b'.', b't', b'a', b'g', b'=', b'1', b'2', b'3', // Word: .tag=123
            0x0C, b'=', b'n', b'a', b'm', b'e', b'=', b'e', b't', b'h', b'e', b'r',
            b'1', // Word: =name=ether1
            0x00, // End of sentence
        ];

        let sentence = next_sentence(&data).unwrap().0;
        let mut sentence = sentence.into_iter();

        assert_eq!(sentence.next().unwrap(), Word::Category(WordCategory::Done));

        assert_eq!(sentence.next().unwrap(), Word::Tag(123));

        assert_eq!(
            sentence.next().unwrap(),
            Word::Attribute(("name", Some("ether1")).into())
        );

        assert_eq!(sentence.next(), None);
    }

    #[test]
    fn test_sentence_with_invalid_length() {
        let data: &[u8] = &[
            0xF8, b'.', b't', b'a', b'g', b'=', b'1', b'2', b'3', // Invalid length prefix
        ];

        let sentence = next_sentence(&data);

        assert!(sentence.is_err());
    }

    #[test]
    fn test_sentence_without_category() {
        let data: &[u8] = &[
            0x0A, b'.', b't', b'a', b'g', b'=', b'1', b'2', b'3', // Word: .tag=123
            0x0D, b'=', b'n', b'a', b'm', b'e', b'=', b'e', b't', b'h', b'e', b'r',
            b'1', // Word: =name=ether1
        ];

        let sentence = next_sentence(&data);

        assert!(sentence.is_err());
    }

    #[test]
    fn test_mixed_words_sentence() {
        let data: &[u8] = &[
            0x03, b'!', b'r', b'e', // Word: !re
            0x04, b'=', b'a', b'=', b'b', // Word: =a=b
            0x08, b'.', b't', b'a', b'g', b'=', b'4', b'5', b'6', // Word: .tag=456
            0x00, // End of sentence
        ];

        let sentence = next_sentence(&data).unwrap().0;
        let mut sentence = sentence.into_iter();

        assert_eq!(
            sentence.next().unwrap(),
            Word::Category(WordCategory::Reply)
        );

        assert_eq!(
            sentence.next().unwrap(),
            Word::Attribute(("a", Some("b")).into())
        );

        assert_eq!(sentence.next().unwrap(), Word::Tag(456));

        assert_eq!(sentence.next(), None);
    }

    #[test]
    fn test_sentence_with_fatal_message() {
        let data: &[u8] = &[
            0x06, b'!', b'f', b'a', b't', b'a', b'l', 0x0B, b's', b'e', b'r', b'v', b'e', b'r',
            b' ', b'd', b'o', b'w', b'n', // Word: !fatal server down
            0x00, // End of sentence
        ];

        let sentence = next_sentence(&data).unwrap().0;
        let mut sentence = sentence.into_iter();

        assert_eq!(
            sentence.next().unwrap(),
            Word::Category(WordCategory::Fatal)
        );

        assert_eq!(
            sentence.next().unwrap(),
            Word::Message("server down".into())
        );

        assert_eq!(sentence.next(), None);
    }

    #[test]
    fn test_complete_sentence_with_extra_data() {
        let data: &[u8] = &[
            0x05, b'!', b'd', b'o', b'n', b'e', // Word: !done
            0x08, b'.', b't', b'a', b'g', b'=', b'1', b'2', b'3', // Word: .tag=123
            0x0C, b'=', b'n', b'a', b'm', b'e', b'=', b'e', b't', b'h', b'e', b'r',
            b'1', // Word: =name=ether1
            0x00, // End of sentence
            0x07, b'!', b'd', b'o', b'n', b'e', // Extra data: !done
        ];

        let sentence = next_sentence(&data).unwrap().0;
        let mut sentence = sentence.into_iter();

        assert_eq!(sentence.next().unwrap(), Word::Category(WordCategory::Done));

        assert_eq!(sentence.next().unwrap(), Word::Tag(123));

        assert_eq!(
            sentence.next().unwrap(),
            Word::Attribute(("name", Some("ether1")).into())
        );

        assert_eq!(sentence.next(), None);

        // Confirm that extra data is ignored after the end of the sentence
        assert_eq!(sentence.next(), None);
    }
    #[test]
    fn test_real_world_sequence_with_null_in_word() {
        let data = [
            0x03, 0x21, 0x72, 0x65, 0x0a, 0x2e, 0x74, 0x61, 0x67, 0x3d, 0x32, 0x34, 0x32, 0x33,
            0x31, 0x07, 0x3d, 0x2e, 0x69, 0x64, 0x3d, 0x2a, 0x35, 0x14, 0x3d, 0x6e, 0x61, 0x6d,
            0x65, 0x3d, 0x47, 0x75, 0x65, 0x74, 0xe4, 0x20, 0x4d, 0x6f, 0x72, 0x67, 0xe4, 0x20,
            0x3d, 0x00, 0x14, 0x3d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x2d, 0x6e, 0x61,
            0x6d, 0x65, 0x3d, 0x65, 0x74, 0x68, 0x65, 0x72, 0x35, 0x09, 0x3d, 0x6d, 0x74, 0x75,
            0x3d, 0x31, 0x35, 0x30, 0x30, 0x0b, 0x3d, 0x6c, 0x32, 0x6d, 0x74, 0x75, 0x3d, 0x31,
            0x35, 0x39, 0x36, 0x1e, 0x3d, 0x6d, 0x61, 0x63, 0x2d, 0x61, 0x64, 0x64, 0x72, 0x65,
            0x73, 0x73, 0x3d, 0x42, 0x38, 0x3a, 0x36, 0x39, 0x3a, 0x46, 0x34, 0x3a, 0x45, 0x34,
            0x3a, 0x44, 0x37, 0x3a, 0x36, 0x42, 0x23, 0x3d, 0x6f, 0x72, 0x69, 0x67, 0x2d, 0x6d,
            0x61, 0x63, 0x2d, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3d, 0x42, 0x38, 0x3a,
            0x36, 0x39, 0x3a, 0x46, 0x34, 0x3a, 0x45, 0x34, 0x3a, 0x44, 0x37, 0x3a, 0x36, 0x42,
            0x0c, 0x3d, 0x61, 0x72, 0x70, 0x3d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x11,
            0x3d, 0x61, 0x72, 0x70, 0x2d, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x3d, 0x61,
            0x75, 0x74, 0x6f, 0x15, 0x3d, 0x6c, 0x6f, 0x6f, 0x70, 0x2d, 0x70, 0x72, 0x6f, 0x74,
            0x65, 0x63, 0x74, 0x3d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x18, 0x3d, 0x6c,
            0x6f, 0x6f, 0x70, 0x2d, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x2d, 0x73, 0x74,
            0x61, 0x74, 0x75, 0x73, 0x3d, 0x6f, 0x66, 0x66, 0x1e, 0x3d, 0x6c, 0x6f, 0x6f, 0x70,
            0x2d, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x2d, 0x73, 0x65, 0x6e, 0x64, 0x2d,
            0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x3d, 0x35, 0x73, 0x1d, 0x3d, 0x6c,
            0x6f, 0x6f, 0x70, 0x2d, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x2d, 0x64, 0x69,
            0x73, 0x61, 0x62, 0x6c, 0x65, 0x2d, 0x74, 0x69, 0x6d, 0x65, 0x3d, 0x35, 0x6d, 0x16,
            0x3d, 0x61, 0x75, 0x74, 0x6f, 0x2d, 0x6e, 0x65, 0x67, 0x6f, 0x74, 0x69, 0x61, 0x74,
            0x69, 0x6f, 0x6e, 0x3d, 0x74, 0x72, 0x75, 0x65, 0x64, 0x3d, 0x61, 0x64, 0x76, 0x65,
            0x72, 0x74, 0x69, 0x73, 0x65, 0x3d, 0x31, 0x30, 0x4d, 0x2d, 0x62, 0x61, 0x73, 0x65,
            0x54, 0x2d, 0x68, 0x61, 0x6c, 0x66, 0x2c, 0x31, 0x30, 0x4d, 0x2d, 0x62, 0x61, 0x73,
            0x65, 0x54, 0x2d, 0x66, 0x75, 0x6c, 0x6c, 0x2c, 0x31, 0x30, 0x30, 0x4d, 0x2d, 0x62,
            0x61, 0x73, 0x65, 0x54, 0x2d, 0x68, 0x61, 0x6c, 0x66, 0x2c, 0x31, 0x30, 0x30, 0x4d,
            0x2d, 0x62, 0x61, 0x73, 0x65, 0x54, 0x2d, 0x66, 0x75, 0x6c, 0x6c, 0x2c, 0x31, 0x47,
            0x2d, 0x62, 0x61, 0x73, 0x65, 0x54, 0x2d, 0x68, 0x61, 0x6c, 0x66, 0x2c, 0x31, 0x47,
            0x2d, 0x62, 0x61, 0x73, 0x65, 0x54, 0x2d, 0x66, 0x75, 0x6c, 0x6c, 0x14, 0x3d, 0x74,
            0x78, 0x2d, 0x66, 0x6c, 0x6f, 0x77, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
            0x3d, 0x6f, 0x66, 0x66, 0x14, 0x3d, 0x72, 0x78, 0x2d, 0x66, 0x6c, 0x6f, 0x77, 0x2d,
            0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x3d, 0x6f, 0x66, 0x66, 0x1e, 0x3d, 0x62,
            0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3d, 0x75, 0x6e, 0x6c, 0x69, 0x6d,
            0x69, 0x74, 0x65, 0x64, 0x2f, 0x75, 0x6e, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64,
            0x0f, 0x3d, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x3d, 0x73, 0x77, 0x69, 0x74, 0x63,
            0x68, 0x31, 0x15, 0x3d, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x2d, 0x72, 0x78, 0x2d,
            0x62, 0x79, 0x74, 0x65, 0x3d, 0x34, 0x37, 0x37, 0x30, 0x36, 0x15, 0x3d, 0x64, 0x72,
            0x69, 0x76, 0x65, 0x72, 0x2d, 0x72, 0x78, 0x2d, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
            0x3d, 0x37, 0x31, 0x31, 0x17, 0x3d, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x2d, 0x74,
            0x78, 0x2d, 0x62, 0x79, 0x74, 0x65, 0x3d, 0x37, 0x38, 0x38, 0x35, 0x38, 0x33, 0x31,
            0x18, 0x3d, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x2d, 0x74, 0x78, 0x2d, 0x70, 0x61,
            0x63, 0x6b, 0x65, 0x74, 0x3d, 0x31, 0x30, 0x33, 0x36, 0x34, 0x36, 0x10, 0x3d, 0x72,
            0x78, 0x2d, 0x62, 0x79, 0x74, 0x65, 0x73, 0x3d, 0x34, 0x35, 0x34, 0x31, 0x30, 0x31,
            0x0f, 0x3d, 0x72, 0x78, 0x2d, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x3d, 0x32, 0x36,
            0x37, 0x38, 0x0f, 0x3d, 0x72, 0x78, 0x2d, 0x74, 0x6f, 0x6f, 0x2d, 0x73, 0x68, 0x6f,
            0x72, 0x74, 0x3d, 0x30, 0x0b, 0x3d, 0x72, 0x78, 0x2d, 0x36, 0x34, 0x3d, 0x32, 0x33,
            0x31, 0x38, 0x0e, 0x3d, 0x72, 0x78, 0x2d, 0x36, 0x35, 0x2d, 0x31, 0x32, 0x37, 0x3d,
            0x31, 0x33, 0x32, 0x0e, 0x3d, 0x72, 0x78, 0x2d, 0x31, 0x32, 0x38, 0x2d, 0x32, 0x35,
            0x35, 0x3d, 0x31, 0x30, 0x0f, 0x3d, 0x72, 0x78, 0x2d, 0x32, 0x35, 0x36, 0x2d, 0x35,
            0x31, 0x31, 0x3d, 0x35, 0x38, 0x39, 0x0e, 0x3d, 0x72, 0x78, 0x2d, 0x35, 0x31, 0x32,
            0x2d, 0x31, 0x30, 0x32, 0x33, 0x3d, 0x32, 0x0f, 0x3d, 0x72, 0x78, 0x2d, 0x31, 0x30,
            0x32, 0x34, 0x2d, 0x31, 0x35, 0x31, 0x38, 0x3d, 0x30, 0x0e, 0x3d, 0x72, 0x78, 0x2d,
            0x74, 0x6f, 0x6f, 0x2d, 0x6c, 0x6f, 0x6e, 0x67, 0x3d, 0x30, 0x10, 0x3d, 0x72, 0x78,
            0x2d, 0x62, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x3d, 0x31, 0x32, 0x0b,
            0x3d, 0x72, 0x78, 0x2d, 0x70, 0x61, 0x75, 0x73, 0x65, 0x3d, 0x30, 0x11, 0x3d, 0x72,
            0x78, 0x2d, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x63, 0x61, 0x73, 0x74, 0x3d, 0x33, 0x36,
            0x30, 0x0f, 0x3d, 0x72, 0x78, 0x2d, 0x66, 0x63, 0x73, 0x2d, 0x65, 0x72, 0x72, 0x6f,
            0x72, 0x3d, 0x31, 0x11, 0x3d, 0x72, 0x78, 0x2d, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x2d,
            0x65, 0x72, 0x72, 0x6f, 0x72, 0x3d, 0x30, 0x11, 0x3d, 0x72, 0x78, 0x2d, 0x66, 0x72,
            0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x3d, 0x34, 0x36, 0x37, 0x36, 0x0c, 0x3d, 0x72,
            0x78, 0x2d, 0x6a, 0x61, 0x62, 0x62, 0x65, 0x72, 0x3d, 0x30, 0x0a, 0x3d, 0x72, 0x78,
            0x2d, 0x64, 0x72, 0x6f, 0x70, 0x3d, 0x30, 0x12, 0x3d, 0x74, 0x78, 0x2d, 0x62, 0x79,
            0x74, 0x65, 0x73, 0x3d, 0x31, 0x36, 0x39, 0x35, 0x33, 0x32, 0x38, 0x36, 0x0f, 0x3d,
            0x74, 0x78, 0x2d, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x3d, 0x32, 0x37, 0x36, 0x39,
            0x0c, 0x3d, 0x74, 0x78, 0x2d, 0x36, 0x34, 0x3d, 0x38, 0x39, 0x33, 0x34, 0x38, 0x0f,
            0x3d, 0x74, 0x78, 0x2d, 0x36, 0x35, 0x2d, 0x31, 0x32, 0x37, 0x3d, 0x36, 0x35, 0x34,
            0x30, 0x11, 0x3d, 0x74, 0x78, 0x2d, 0x31, 0x32, 0x38, 0x2d, 0x32, 0x35, 0x35, 0x3d,
            0x35, 0x38, 0x31, 0x30, 0x33, 0x0f, 0x3d, 0x74, 0x78, 0x2d, 0x32, 0x35, 0x36, 0x2d,
            0x35, 0x31, 0x31, 0x3d, 0x35, 0x39, 0x36, 0x0e, 0x3d, 0x74, 0x78, 0x2d, 0x35, 0x31,
            0x32, 0x2d, 0x31, 0x30, 0x32, 0x33, 0x3d, 0x38, 0x0f, 0x3d, 0x74, 0x78, 0x2d, 0x31,
            0x30, 0x32, 0x34, 0x2d, 0x31, 0x35, 0x31, 0x38, 0x3d, 0x34, 0x13, 0x3d, 0x74, 0x78,
            0x2d, 0x62, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x3d, 0x32, 0x33, 0x30,
            0x37, 0x37, 0x0b, 0x3d, 0x74, 0x78, 0x2d, 0x70, 0x61, 0x75, 0x73, 0x65, 0x3d, 0x30,
            0x14, 0x3d, 0x74, 0x78, 0x2d, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x63, 0x61, 0x73, 0x74,
            0x3d, 0x31, 0x32, 0x38, 0x37, 0x35, 0x33, 0x0f, 0x3d, 0x74, 0x78, 0x2d, 0x63, 0x6f,
            0x6c, 0x6c, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x30, 0x19, 0x3d, 0x74, 0x78, 0x2d,
            0x65, 0x78, 0x63, 0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x2d, 0x63, 0x6f, 0x6c, 0x6c,
            0x69, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x30, 0x18, 0x3d, 0x74, 0x78, 0x2d, 0x6d, 0x75,
            0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x2d, 0x63, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x69,
            0x6f, 0x6e, 0x3d, 0x30, 0x16, 0x3d, 0x74, 0x78, 0x2d, 0x73, 0x69, 0x6e, 0x67, 0x6c,
            0x65, 0x2d, 0x63, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x30, 0x0e,
            0x3d, 0x74, 0x78, 0x2d, 0x64, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x3d, 0x30,
            0x14, 0x3d, 0x74, 0x78, 0x2d, 0x6c, 0x61, 0x74, 0x65, 0x2d, 0x63, 0x6f, 0x6c, 0x6c,
            0x69, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x30, 0x0a, 0x3d, 0x74, 0x78, 0x2d, 0x64, 0x72,
            0x6f, 0x70, 0x3d, 0x30, 0x0f, 0x3d, 0x74, 0x78, 0x2d, 0x66, 0x63, 0x73, 0x2d, 0x65,
            0x72, 0x72, 0x6f, 0x72, 0x3d, 0x30, 0x0d, 0x3d, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e,
            0x67, 0x3d, 0x74, 0x72, 0x75, 0x65, 0x0b, 0x3d, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x3d,
            0x74, 0x72, 0x75, 0x65, 0x0f, 0x3d, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64,
            0x3d, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x00, 0x05, 0x21, 0x64, 0x6f, 0x6e, 0x65, 0x0a,
            0x2e, 0x74, 0x61, 0x67, 0x3d, 0x32, 0x34, 0x32, 0x33, 0x31, 0x00,
        ];

        let mut pos = 0;
        let mut sentences = Vec::new();
        loop {
            match next_sentence(&data[pos..]) {
                Ok((sentence, next_pos)) => {
                    pos += next_pos;
                    sentences.push(sentence);
                }
                Err(SentenceError::Incomplete) => break,
                Err(SentenceError::WordError(e)) => {
                    panic!("Word error {:?}", e);
                }
                Err(SentenceError::PrefixLength) => {
                    panic!("Prefix length error")
                }
            }
        }
        assert_eq!(sentences.len(), 2);
        let first_sentence = sentences.first().unwrap();
        assert_eq!(
            Some(&Word::Category(WordCategory::Reply)),
            first_sentence.get(0)
        );
        assert_eq!(Some(&Word::Tag(24231)), first_sentence.get(1));
        assert_eq!(
            Some(&Word::Attribute(WordAttribute {
                key: "name".into(),
                value: Some("Guetä Morgä =\0".into())
            })),
            first_sentence.get(3)
        );

        let final_sentence = sentences.get(1).unwrap();
        assert_eq!(
            Some(&Word::Category(WordCategory::Done)),
            final_sentence.get(0)
        );

        assert_eq!(pos, data.len());
    }
}
